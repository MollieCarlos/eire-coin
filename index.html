<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BSC Arbitrage Bot – Auto 10s Refresh</title>
  <script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
  <style>
    body { font-family: Arial; background: #111; color: #0f0; padding: 20px; }
    .bot { max-width: 600px; margin: 20px auto; padding: 20px; border: 2px solid #0f0; border-radius: 12px; }
    button { width: 100%; padding: 14px; margin: 10px 0; font-size: 18px; background: #0a0; color: #000; border: none; border-radius: 8px; }
    input { width: 100%; padding: 12px; margin: 10px 0; background: #222; color: #0f0; border: 1px solid #0f0; border-radius: 6px; }
    .opp { background: #222; padding: 15px; border-radius: 8px; margin: 15px 0; }
    .profit { font-weight: bold; color: #0f0; }
    #status { margin: 15px 0; font-weight: bold; }
  </style>
</head>
<body>

<div class="bot">
  <h2 style="text-align:center; margin:0 0 20px;">BSC Arbitrage Bot – Auto 10s Scan</h2>

  <button id="connectBtn">Connect Any Wallet</button>
  <div id="wallet" style="margin:12px 0; font-weight:bold;"></div>

  <input type="number" id="amount" placeholder="BNB Amount" value="0.013" step="0.001">

  <div id="status">Status: Not connected</div>
  <div id="opportunities"></div>
</div>

<script>
  const WBNB = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c";
  const COINS = [
    { addr: "0x55d398326f99059fF775485246999027B3197955", sym: "USDT" },
    { addr: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", sym: "BUSD" },
    { addr: "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82", sym: "CAKE" },
    { addr: "0x8076c74c5e3f5852037f31ff0093eeb8c8add8d3", sym: "SAFEMOON" },
    { addr: "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3", sym: "DAI" }
  ];

  let web3, account, intervalId;

  document.getElementById("connectBtn").onclick = async () => {
    if (!window.ethereum) return updateStatus("No wallet! Install MetaMask/Trust Wallet.");
    web3 = new Web3(window.ethereum);
    try {
      await ethereum.request({ method: 'eth_requestAccounts' });
      account = (await web3.eth.getAccounts())[0];
      document.getElementById("wallet").innerText = `Wallet: ${account.slice(0,8)}...${account.slice(-6)}`;
      updateStatus("Connected! Auto-scan every 10s...");
      startAutoScan();
    } catch (e) { updateStatus("Wallet rejected"); }
  };

  function startAutoScan() {
    if (intervalId) clearInterval(intervalId);
    scanOnce();
    intervalId = setInterval(scanOnce, 10000); // Every 10 seconds
  }

  async function scanOnce() {
    if (!account) return;
    updateStatus("Scanning 5+ coins...");
    document.getElementById("opportunities").innerHTML = "";

    const amountBNB = parseFloat(document.getElementById("amount").value) || 0.013;
    const amountWei = web3.utils.toWei(amountBNB.toString(), "ether");

    let best = null;

    for (const coin of COINS) {
      try {
        const buy = await getQuote(WBNB, coin.addr, amountWei);
        if (!buy || !buy.toAmount) continue;

        const sell = await getQuote(coin.addr, WBNB, buy.toAmount);
        if (!sell || !sell.toAmount) continue;

        const profitWei = BigInt(sell.toAmount) - BigInt(amountWei);
        const gasPrice = await web3.eth.getGasPrice();
        const gasEst = BigInt(gasPrice) * BigInt(450000);
        const netProfit = profitWei - gasEst;

        if (netProfit > 0n) {
          const profitBNB = Number(netProfit) / 1e18;
          const profitPct = (profitBNB / amountBNB) * 100;

          if (!best || profitPct > best.profitPct) {
            best = { ...coin, buy, sell, profitBNB, profitPct, amountBNB };
          }
        }
      } catch (e) { continue; }
    }

    if (best) {
      showOpportunity(best);
    } else {
      updateStatus("No good coins found this scan.");
    }
  }

  async function getQuote(from, to, amount) {
    const url = `https://li.quest/v1/quote?fromChain=BSC&toChain=BSC&fromToken=${from}&toToken=${to}&fromAmount=${amount}&fromAddress=${account}`;
    try {
      const res = await fetch(url, { timeout: 8000 });
      if (!res.ok) return null;
      return await res.json();
    } catch { return null; }
  }

  function showOpportunity(data) {
    const div = document.createElement("div");
    div.className = "opp";
    div.innerHTML = `
      <b>GOOD COIN FOUND!</b><br>
      Token: <b>${data.sym}</b><br>
      Buy on <b>Li.Fi</b> → Sell on <b>Li.Fi</b><br>
      Invest: ${data.amountBNB} BNB<br>
      <span class="profit">Profit: ${data.profitBNB.toFixed(6)} BNB (${data.profitPct.toFixed(2)}%)</span><br>
      <button onclick="execute('${btoa(JSON.stringify(data.buy.transaction.request))}', '${btoa(JSON.stringify(data.sell.transaction.request))}')" 
              style="margin-top:10px; width:100%; padding:12px; background:#0f0; color:#000; border:none; border-radius:8px;">
        Execute Now
      </button>
    `;
    const container = document.getElementById("opportunities");
    container.innerHTML = "";
    container.appendChild(div);
  }

  window.execute = async (buyB64, sellB64) => {
    try {
      updateStatus("Sending BUY...");
      const buyTx = JSON.parse(atob(buyB64));
      await ethereum.request({ method: 'eth_sendTransaction', params: [{ from: account, ...buyTx }] });

      updateStatus("BUY sent! Waiting 12s...");
      await new Promise(r => setTimeout(r, 12000));

      updateStatus("Sending SELL...");
      const sellTx = JSON.parse(atob(sellB64));
      await ethereum.request({ method: 'eth_sendTransaction', params: [{ from: account, ...sellTx }] });

      updateStatus("Arbitrage complete! Refreshing in 10s...");
    } catch (e) {
      updateStatus("Failed: " + (e.message || "Rejected"));
    }
  };

  function updateStatus(msg) {
    document.getElementById("status").innerText = "Status: " + msg;
  }
</script>

</body>
</html>
